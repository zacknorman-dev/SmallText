#include "LoRaMessenger.h"

// Static member for interrupt-driven reception
volatile bool LoRaMessenger::receivedFlag = false;

void LoRaMessenger::setFlag(void) {
    receivedFlag = true;
}

LoRaMessenger::LoRaMessenger() {
    radio = nullptr;
    encryption = nullptr;
    myVillageName = "";
    myUsername = "";
    myMAC = ESP.getEfuseMac();
    onMessageReceived = nullptr;
    lastSeenCleanup = 0;
}

uint32_t LoRaMessenger::generateVillageId(const String& villageName) {
    // Simple hash function to generate village ID from name
    uint32_t hash = 0;
    for (size_t i = 0; i < villageName.length(); i++) {
        hash = hash * 31 + villageName[i];
    }
    return hash;
}

bool LoRaMessenger::begin(int csPin, int dio1Pin, int resetPin, int busyPin) {
    // Initialize SX1262 for Heltec Vision Master E290
    radio = new SX1262(new Module(csPin, dio1Pin, resetPin, busyPin));
    
    Serial.print(F("[LoRa] Initializing ... "));
    
    // For E290, typical settings:
    // Frequency: 915 MHz (US) or 868 MHz (EU)
    // Bandwidth: 125 kHz
    // Spreading Factor: 9
    // Output Power: 22 dBm
    
    int state = radio->begin(915.0, 125.0, 9, 7, RADIOLIB_SX126X_SYNC_WORD_PRIVATE, 22);
    
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println(F("success!"));
        
        // Set up interrupt-driven async reception
        radio->setPacketReceivedAction(setFlag);
        receivedFlag = false;
        
        // Start receiver in async mode
        radio->startReceive();
        
        return true;
    } else {
        Serial.print(F("failed, code "));
        Serial.println(state);
        return false;
    }
}

void LoRaMessenger::setEncryption(Encryption* enc) {
    encryption = enc;
}

void LoRaMessenger::setVillageInfo(const String& villageName, const String& username) {
    myVillageName = villageName;
    myUsername = username;
}

void LoRaMessenger::setMessageCallback(void (*callback)(const Message& msg)) {
    onMessageReceived = callback;
}

bool LoRaMessenger::sendMessage(const String& message) {
    if (!radio || !encryption) {
        return false;
    }
    
    // Encrypt the message
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    
    if (!encryption->encryptString(message, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F("[LoRa] Encryption failed"));
        return false;
    }
    
    // Build packet: [village_id][sender_len][sender][encrypted_msg]
    uint8_t packet[MAX_LORA_PAYLOAD];
    size_t packetLen = 0;
    
    // Add village ID
    memcpy(packet + packetLen, &villageId, VILLAGE_ID_SIZE);
    packetLen += VILLAGE_ID_SIZE;
    
    // Add sender username length and username
    uint8_t senderLen = myUsername.length();
    packet[packetLen++] = senderLen;
    memcpy(packet + packetLen, myUsername.c_str(), senderLen);
    packetLen += senderLen;
    
    // Add encrypted message
    if (packetLen + encryptedLen > MAX_LORA_PAYLOAD) {
        Serial.println(F("[LoRa] Message too long"));
        return false;
    }
    
    memcpy(packet + packetLen, encrypted, encryptedLen);
    packetLen += encryptedLen;
    
    // Send via LoRa
    Serial.print(F("[LoRa] Sending message ... "));
    int state = radio->transmit(packet, packetLen);
    
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println(F("success!"));
        radio->startReceive();  // Go back to receive mode
        return true;
    } else {
        Serial.print(F("failed, code "));
        Serial.println(state);
        radio->startReceive();
        return false;
    }
}

void LoRaMessenger::checkForMessages() {
    if (!radio || !encryption) {
        return;
    }
    
    // Check if a packet is available
    if (radio->getPacketLength() > 0) {
        uint8_t packet[MAX_LORA_PAYLOAD];
        int state = radio->readData(packet, MAX_LORA_PAYLOAD);
        
        if (state == RADIOLIB_ERR_NONE) {
            size_t packetLen = radio->getPacketLength();
            
            // Parse packet
            size_t offset = 0;
            
            // Check village ID
            if (packetLen < VILLAGE_ID_SIZE + 1) {
                Serial.println(F("[LoRa] Invalid packet (too short)"));
                radio->startReceive();
                return;
            }
            
            uint32_t receivedVillageId;
            memcpy(&receivedVillageId, packet + offset, VILLAGE_ID_SIZE);
            offset += VILLAGE_ID_SIZE;
            
            if (receivedVillageId != villageId) {
                // Not for our village, ignore
                radio->startReceive();
                return;
            }
            
            // Extract sender username
            uint8_t senderLen = packet[offset++];
            if (offset + senderLen > packetLen) {
                Serial.println(F("[LoRa] Invalid packet (sender overflow)"));
                radio->startReceive();
                return;
            }
            
            char sender[MAX_USERNAME];
            memcpy(sender, packet + offset, senderLen);
            sender[senderLen] = '\0';
            offset += senderLen;
            
            // Decrypt message
            size_t encryptedLen = packetLen - offset;
            String decryptedMessage;
            
            if (encryption->decryptString(packet + offset, encryptedLen, decryptedMessage)) {
                // Create message struct
                Message msg;
                msg.sender = String(sender);
                msg.content = decryptedMessage;
                msg.timestamp = millis();
                msg.received = true;
                
                // Call callback
                if (onMessageReceived) {
                    onMessageReceived(msg);
                }
                
                Serial.print(F("[LoRa] Message received from "));
                Serial.print(msg.sender);
                Serial.print(": ");
                Serial.println(msg.content);
            } else {
                Serial.println(F("[LoRa] Decryption failed (wrong key or corrupted)"));
            }
        }
        
        // Start receiving again
        radio->startReceive();
    }
}

void LoRaMessenger::setFrequency(float freq) {
    if (radio) {
        radio->setFrequency(freq);
    }
}

void LoRaMessenger::setBandwidth(float bw) {
    if (radio) {
        radio->setBandwidth(bw);
    }
}

void LoRaMessenger::setSpreadingFactor(uint8_t sf) {
    if (radio) {
        radio->setSpreadingFactor(sf);
    }
}

void LoRaMessenger::setOutputPower(int8_t power) {
    if (radio) {
        radio->setOutputPower(power);
    }
}

bool LoRaMessenger::sendRaw(const String& message) {
    if (!radio) return false;
    
    int state = radio->transmit(message.c_str());
    
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println(F("[LoRa] Raw message sent"));
        radio->startReceive();  // Go back to receive mode
        return true;
    } else {
        Serial.print(F("[LoRa] Send failed, code "));
        Serial.println(state);
        return false;
    }
}

String LoRaMessenger::checkForMessage() {
    if (!radio) return "";
    
    // Only check if interrupt flag is set (new packet arrived)
    if (!receivedFlag) {
        return "";  // No new packet
    }
    
    // Clear the flag FIRST to prevent re-processing
    receivedFlag = false;
    
    // Read the packet
    uint8_t buffer[256];
    int state = radio->readData(buffer, sizeof(buffer));
    
    // Restart receive mode for next packet
    radio->startReceive();
    
    // Only process if we successfully read a packet
    if (state == RADIOLIB_ERR_NONE) {
        size_t len = radio->getPacketLength();
        
        // Ignore empty or oversized packets
        if (len == 0 || len > sizeof(buffer) - 1) {
            return "";
        }
        
        // Null terminate and convert to String
        buffer[len] = 0;
        String received = String((char*)buffer);
        
        Serial.print(F("[LoRa] Received: "));
        Serial.println(received);
        Serial.print(F("[LoRa] RSSI: "));
        Serial.print(radio->getRSSI());
        Serial.println(F(" dBm"));
        
        return received;
    }
    
    // Read failed
    return "";
}

// ============================================================================
// NEW MESSAGE PROTOCOL IMPLEMENTATION
// ============================================================================

String LoRaMessenger::generateMessageId() {
    // Generate unique message ID: timestamp + random
    static uint32_t counter = 0;
    counter++;
    char id[16];
    snprintf(id, sizeof(id), "%08lx%04x", millis(), (counter & 0xFFFF));
    return String(id);
}

String LoRaMessenger::formatMessage(MessageType type, const String& target, const String& content, int maxHop) {
    // Format: "TYPE:villageName:target:senderMAC:msgId:content:hop:maxHop"
    String typeStr;
    switch (type) {
        case MSG_SHOUT: typeStr = "SHOUT"; break;
        case MSG_GROUP: typeStr = "GROUP"; break;
        case MSG_WHISPER: typeStr = "WHISPER"; break;
        case MSG_ACK: typeStr = "ACK"; break;
        default: typeStr = "UNKNOWN"; break;
    }
    
    String msg = typeStr + ":" + myVillageName + ":" + target + ":" + 
                 String(myMAC, HEX) + ":" + generateMessageId() + ":" + 
                 content + ":0:" + String(maxHop);
    
    return msg;
}

ParsedMessage LoRaMessenger::parseMessage(const String& decrypted) {
    ParsedMessage pm;
    
    // Split by colons: TYPE:village:target:sender:msgId:content:hop:maxHop
    int idx = 0;
    int lastIdx = 0;
    String parts[8];
    int partCount = 0;
    
    while (idx < decrypted.length() && partCount < 8) {
        idx = decrypted.indexOf(':', lastIdx);
        if (idx == -1) {
            parts[partCount++] = decrypted.substring(lastIdx);
            break;
        }
        parts[partCount++] = decrypted.substring(lastIdx, idx);
        lastIdx = idx + 1;
    }
    
    if (partCount < 8) {
        Serial.println(F("[LoRa] Invalid message format"));
        return pm;  // Returns MSG_UNKNOWN
    }
    
    // Parse type
    if (parts[0] == "SHOUT") pm.type = MSG_SHOUT;
    else if (parts[0] == "GROUP") pm.type = MSG_GROUP;
    else if (parts[0] == "WHISPER") pm.type = MSG_WHISPER;
    else if (parts[0] == "ACK") pm.type = MSG_ACK;
    else pm.type = MSG_UNKNOWN;
    
    pm.villageName = parts[1];
    pm.target = parts[2];
    pm.senderMAC = parts[3];
    pm.messageId = parts[4];
    pm.content = parts[5];
    pm.currentHop = parts[6].toInt();
    pm.maxHop = parts[7].toInt();
    
    return pm;
}

bool LoRaMessenger::isGarbage(const String& text) {
    // Detect failed decryption: >30% unprintable characters
    int unprintableCount = 0;
    for (size_t i = 0; i < text.length(); i++) {
        char c = text[i];
        if (c < 32 && c != '\n' && c != '\t' && c != '\r') {
            unprintableCount++;
        }
    }
    
    float unprintableRatio = (float)unprintableCount / text.length();
    return unprintableRatio > 0.3;
}

bool LoRaMessenger::sendShout(const String& message) {
    if (!encryption) {
        Serial.println(F("[LoRa] No encryption set"));
        return false;
    }
    
    // SHOUT messages use mesh immediately (max_hop=3)
    String formatted = formatMessage(MSG_SHOUT, "*", message, 3);
    
    // Encrypt
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    if (!encryption->encryptString(formatted, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F("[LoRa] Encryption failed"));
        return false;
    }
    
    // Transmit
    int state = radio->transmit(encrypted, encryptedLen);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.print(F("[LoRa] SHOUT sent: "));
        Serial.println(message);
        return true;
    }
    
    Serial.print(F("[LoRa] Transmit failed, code "));
    Serial.println(state);
    return false;
}

bool LoRaMessenger::sendGroup(const String& groupName, const String& message) {
    if (!encryption) {
        Serial.println(F("[LoRa] No encryption set"));
        return false;
    }
    
    // GROUP messages try direct first (max_hop=0), will escalate if needed
    String formatted = formatMessage(MSG_GROUP, groupName, message, 0);
    
    // Encrypt
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    if (!encryption->encryptString(formatted, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F("[LoRa] Encryption failed"));
        return false;
    }
    
    // Transmit
    int state = radio->transmit(encrypted, encryptedLen);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.print(F("[LoRa] GROUP sent to "));
        Serial.print(groupName);
        Serial.print(F(": "));
        Serial.println(message);
        return true;
    }
    
    Serial.print(F("[LoRa] Transmit failed, code "));
    Serial.println(state);
    return false;
}

bool LoRaMessenger::sendWhisper(const String& recipientMAC, const String& message) {
    if (!encryption) {
        Serial.println(F("[LoRa] No encryption set"));
        return false;
    }
    
    // WHISPER messages try direct first (max_hop=0), will escalate if needed
    String formatted = formatMessage(MSG_WHISPER, recipientMAC, message, 0);
    
    // Encrypt
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    if (!encryption->encryptString(formatted, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F("[LoRa] Encryption failed"));
        return false;
    }
    
    // Transmit
    int state = radio->transmit(encrypted, encryptedLen);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.print(F("[LoRa] WHISPER sent to "));
        Serial.print(recipientMAC);
        Serial.print(F(": "));
        Serial.println(message);
        return true;
    }
    
    Serial.print(F("[LoRa] Transmit failed, code "));
    Serial.println(state);
    return false;
}

void LoRaMessenger::loop() {
    // Clean up old seen message IDs every 60 seconds
    if (millis() - lastSeenCleanup > 60000) {
        seenMessageIds.clear();
        lastSeenCleanup = millis();
    }
    
    // Check for new messages
    if (!receivedFlag) {
        return;
    }
    
    receivedFlag = false;
    
    if (!radio || !encryption) {
        radio->startReceive();
        return;
    }
    
    // Read packet
    uint8_t buffer[256];
    int state = radio->readData(buffer, sizeof(buffer));
    
    // Restart receiver
    radio->startReceive();
    
    if (state != RADIOLIB_ERR_NONE) {
        return;
    }
    
    size_t len = radio->getPacketLength();
    if (len == 0 || len > sizeof(buffer) - 1) {
        return;
    }
    
    // Decrypt
    uint8_t decrypted[256];
    size_t decryptedLen;
    if (!encryption->decrypt(buffer, len, decrypted, sizeof(decrypted), &decryptedLen)) {
        Serial.println(F("[LoRa] Decryption failed"));
        return;
    }
    
    decrypted[decryptedLen] = 0;
    String decryptedStr = String((char*)decrypted);
    
    // Check for garbage (failed decryption from wrong key)
    if (isGarbage(decryptedStr)) {
        Serial.println(F("[LoRa] Garbage message dropped"));
        return;
    }
    
    // Parse message
    ParsedMessage pm = parseMessage(decryptedStr);
    if (pm.type == MSG_UNKNOWN) {
        return;
    }
    
    // Check if we've seen this message before (duplicate detection)
    if (seenMessageIds.count(pm.messageId)) {
        Serial.println(F("[LoRa] Duplicate message dropped"));
        return;
    }
    seenMessageIds.insert(pm.messageId);
    
    // Check if message is for our village
    if (pm.villageName != myVillageName) {
        Serial.println(F("[LoRa] Wrong village, dropped"));
        return;
    }
    
    Serial.print(F("[LoRa] Received "));
    Serial.print(pm.type == MSG_SHOUT ? "SHOUT" : pm.type == MSG_GROUP ? "GROUP" : "WHISPER");
    Serial.print(F(" from "));
    Serial.print(pm.senderMAC);
    Serial.print(F(": "));
    Serial.println(pm.content);
    Serial.print(F("[LoRa] RSSI: "));
    Serial.print(radio->getRSSI());
    Serial.println(F(" dBm"));
    
    // Handle the message (forward if needed, display if for us)
    handleReceivedMessage(pm);
}

void LoRaMessenger::handleReceivedMessage(const ParsedMessage& msg) {
    // Check if message is for me
    bool forMe = false;
    if (msg.type == MSG_SHOUT) {
        forMe = true;  // SHOUT is for everyone
    } else if (msg.type == MSG_GROUP) {
        forMe = true;  // GROUP filtering happens in UI
    } else if (msg.type == MSG_WHISPER) {
        forMe = (msg.target == String(myMAC, HEX));  // WHISPER only if target matches
    }
    
    if (forMe) {
        // Display message (call callback if set)
        if (onMessageReceived) {
            Message m;
            m.sender = msg.senderMAC;
            m.content = msg.content;
            m.timestamp = millis();
            m.received = true;
            onMessageReceived(m);
        }
        
        // TODO: Send ACK for WHISPER messages
    }
    
    // Check if we should forward (mesh networking)
    if (shouldForward(msg)) {
        Serial.println(F("[LoRa] Forwarding message..."));
        // TODO: Implement forwarding
    }
}

bool LoRaMessenger::shouldForward(const ParsedMessage& msg) {
    // Don't forward if hop limit reached
    if (msg.currentHop >= msg.maxHop) {
        return false;
    }
    
    // Don't forward ACK messages (for now)
    if (msg.type == MSG_ACK) {
        return false;
    }
    
    // Don't forward messages addressed directly to me
    if (msg.type == MSG_WHISPER && msg.target == String(myMAC, HEX)) {
        return false;
    }
    
    return true;
}

// ============================================================================
// NEW MESSAGE PROTOCOL IMPLEMENTATION
// ============================================================================

String LoRaMessenger::generateMessageId() {
    // Generate unique message ID: timestamp + random
    static uint32_t counter = 0;
    counter++;
    char id[16];
    snprintf(id, sizeof(id), "%08lx%04x", millis(), (counter & 0xFFFF));
    return String(id);
}

String LoRaMessenger::formatMessage(MessageType type, const String& target, const String& content, int maxHop) {
    // Format: \"TYPE:villageName:target:senderMAC:msgId:content:hop:maxHop\"
    String typeStr;
    switch (type) {
        case MSG_SHOUT: typeStr = \"SHOUT\"; break;
        case MSG_GROUP: typeStr = \"GROUP\"; break;
        case MSG_WHISPER: typeStr = \"WHISPER\"; break;
        case MSG_ACK: typeStr = \"ACK\"; break;
        default: typeStr = \"UNKNOWN\"; break;
    }
    
    String msg = typeStr + \":\" + myVillageName + \":\" + target + \":\" + 
                 String(myMAC, HEX) + \":\" + generateMessageId() + \":\" + 
                 content + \":0:\" + String(maxHop);
    
    return msg;
}

ParsedMessage LoRaMessenger::parseMessage(const String& decrypted) {
    ParsedMessage pm;
    
    // Split by colons: TYPE:village:target:sender:msgId:content:hop:maxHop
    int idx = 0;
    int lastIdx = 0;
    String parts[8];
    int partCount = 0;
    
    while (idx < decrypted.length() && partCount < 8) {
        idx = decrypted.indexOf(':', lastIdx);
        if (idx == -1) {
            parts[partCount++] = decrypted.substring(lastIdx);
            break;
        }
        parts[partCount++] = decrypted.substring(lastIdx, idx);
        lastIdx = idx + 1;
    }
    
    if (partCount < 8) {
        Serial.println(F(\"[LoRa] Invalid message format\"));
        return pm;  // Returns MSG_UNKNOWN
    }
    
    // Parse type
    if (parts[0] == \"SHOUT\") pm.type = MSG_SHOUT;
    else if (parts[0] == \"GROUP\") pm.type = MSG_GROUP;
    else if (parts[0] == \"WHISPER\") pm.type = MSG_WHISPER;
    else if (parts[0] == \"ACK\") pm.type = MSG_ACK;
    else pm.type = MSG_UNKNOWN;
    
    pm.villageName = parts[1];
    pm.target = parts[2];
    pm.senderMAC = parts[3];
    pm.messageId = parts[4];
    pm.content = parts[5];
    pm.currentHop = parts[6].toInt();
    pm.maxHop = parts[7].toInt();
    
    return pm;
}

bool LoRaMessenger::isGarbage(const String& text) {
    // Detect failed decryption: >30% unprintable characters
    int unprintableCount = 0;
    for (size_t i = 0; i < text.length(); i++) {
        char c = text[i];
        if (c < 32 && c != '\\n' && c != '\\t' && c != '\\r') {
            unprintableCount++;
        }
    }
    
    float unprintableRatio = (float)unprintableCount / text.length();
    return unprintableRatio > 0.3;
}

bool LoRaMessenger::sendShout(const String& message) {
    if (!encryption) {
        Serial.println(F(\"[LoRa] No encryption set\"));
        return false;
    }
    
    // SHOUT messages use mesh immediately (max_hop=3)
    String formatted = formatMessage(MSG_SHOUT, \"*\", message, 3);
    
    // Encrypt
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    if (!encryption->encryptString(formatted, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F(\"[LoRa] Encryption failed\"));
        return false;
    }
    
    // Transmit
    int state = radio->transmit(encrypted, encryptedLen);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.print(F(\"[LoRa] SHOUT sent: \"));
        Serial.println(message);
        return true;
    }
    
    Serial.print(F(\"[LoRa] Transmit failed, code \"));
    Serial.println(state);
    return false;
}

bool LoRaMessenger::sendGroup(const String& groupName, const String& message) {
    if (!encryption) {
        Serial.println(F(\"[LoRa] No encryption set\"));
        return false;
    }
    
    // GROUP messages try direct first (max_hop=0), will escalate if needed
    String formatted = formatMessage(MSG_GROUP, groupName, message, 0);
    
    // Encrypt
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    if (!encryption->encryptString(formatted, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F(\"[LoRa] Encryption failed\"));
        return false;
    }
    
    // Transmit
    int state = radio->transmit(encrypted, encryptedLen);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.print(F(\"[LoRa] GROUP sent to \"));
        Serial.print(groupName);
        Serial.print(F(\": \"));
        Serial.println(message);
        return true;
    }
    
    Serial.print(F(\"[LoRa] Transmit failed, code \"));
    Serial.println(state);
    return false;
}

bool LoRaMessenger::sendWhisper(const String& recipientMAC, const String& message) {
    if (!encryption) {
        Serial.println(F(\"[LoRa] No encryption set\"));
        return false;
    }
    
    // WHISPER messages try direct first (max_hop=0), will escalate if needed
    String formatted = formatMessage(MSG_WHISPER, recipientMAC, message, 0);
    
    // Encrypt
    uint8_t encrypted[MAX_CIPHERTEXT];
    size_t encryptedLen;
    if (!encryption->encryptString(formatted, encrypted, MAX_CIPHERTEXT, &encryptedLen)) {
        Serial.println(F(\"[LoRa] Encryption failed\"));
        return false;
    }
    
    // Transmit
    int state = radio->transmit(encrypted, encryptedLen);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.print(F(\"[LoRa] WHISPER sent to \"));
        Serial.print(recipientMAC);
        Serial.print(F(\": \"));
        Serial.println(message);
        return true;
    }
    
    Serial.print(F(\"[LoRa] Transmit failed, code \"));
    Serial.println(state);
    return false;
}

void LoRaMessenger::loop() {
    // Clean up old seen message IDs every 60 seconds
    if (millis() - lastSeenCleanup > 60000) {
        seenMessageIds.clear();
        lastSeenCleanup = millis();
    }
    
    // Check for new messages
    if (!receivedFlag) {
        return;
    }
    
    receivedFlag = false;
    
    if (!radio || !encryption) {
        radio->startReceive();
        return;
    }
    
    // Read packet
    uint8_t buffer[256];
    int state = radio->readData(buffer, sizeof(buffer));
    
    // Restart receiver
    radio->startReceive();
    
    if (state != RADIOLIB_ERR_NONE) {
        return;
    }
    
    size_t len = radio->getPacketLength();
    if (len == 0 || len > sizeof(buffer) - 1) {
        return;
    }
    
    // Decrypt
    uint8_t decrypted[256];
    size_t decryptedLen;
    if (!encryption->decrypt(buffer, len, decrypted, sizeof(decrypted), &decryptedLen)) {
        Serial.println(F(\"[LoRa] Decryption failed\"));
        return;
    }
    
    decrypted[decryptedLen] = 0;
    String decryptedStr = String((char*)decrypted);
    
    // Check for garbage (failed decryption from wrong key)
    if (isGarbage(decryptedStr)) {
        Serial.println(F(\"[LoRa] Garbage message dropped\"));
        return;
    }
    
    // Parse message
    ParsedMessage pm = parseMessage(decryptedStr);
    if (pm.type == MSG_UNKNOWN) {
        return;
    }
    
    // Check if we've seen this message before (duplicate detection)
    if (seenMessageIds.count(pm.messageId)) {
        Serial.println(F(\"[LoRa] Duplicate message dropped\"));
        return;
    }
    seenMessageIds.insert(pm.messageId);
    
    // Check if message is for our village
    if (pm.villageName != myVillageName) {
        Serial.println(F(\"[LoRa] Wrong village, dropped\"));
        return;
    }
    
    Serial.print(F(\"[LoRa] Received \"));
    Serial.print(pm.type == MSG_SHOUT ? \"SHOUT\" : pm.type == MSG_GROUP ? \"GROUP\" : \"WHISPER\");
    Serial.print(F(\" from \"));
    Serial.print(pm.senderMAC);
    Serial.print(F(\": \"));
    Serial.println(pm.content);
    Serial.print(F(\"[LoRa] RSSI: \"));
    Serial.print(radio->getRSSI());
    Serial.println(F(\" dBm\"));
    
    // Handle the message (forward if needed, display if for us)
    handleReceivedMessage(pm);
}

void LoRaMessenger::handleReceivedMessage(const ParsedMessage& msg) {
    // Check if message is for me
    bool forMe = false;
    if (msg.type == MSG_SHOUT) {
        forMe = true;  // SHOUT is for everyone
    } else if (msg.type == MSG_GROUP) {
        forMe = true;  // GROUP filtering happens in UI
    } else if (msg.type == MSG_WHISPER) {
        forMe = (msg.target == String(myMAC, HEX));  // WHISPER only if target matches
    }
    
    if (forMe) {
        // Display message (call callback if set)
        if (onMessageReceived) {
            Message m;
            m.sender = msg.senderMAC;
            m.content = msg.content;
            m.timestamp = millis();
            m.received = true;
            onMessageReceived(m);
        }
        
        // TODO: Send ACK for WHISPER messages
    }
    
    // Check if we should forward (mesh networking)
    if (shouldForward(msg)) {
        Serial.println(F(\"[LoRa] Forwarding message...\"));
        // TODO: Implement forwarding
    }
}

bool LoRaMessenger::shouldForward(const ParsedMessage& msg) {
    // Don't forward if hop limit reached
    if (msg.currentHop >= msg.maxHop) {
        return false;
    }
    
    // Don't forward ACK messages (for now)
    if (msg.type == MSG_ACK) {
        return false;
    }
    
    // Don't forward messages addressed directly to me
    if (msg.type == MSG_WHISPER && msg.target == String(myMAC, HEX)) {
        return false;
    }
    
    return true;
}
